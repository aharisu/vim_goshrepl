;=============================================================================
; FILE: gosh_repl.vim
; AUTHOR:  aharisu <foo.yobina@gmail.com>
; Last Modified: 30 Oct 2012.
; License: MIT license;{{{
;     Permission is hereby granted, free of charge, to any person obtaining
;     a copy of this software and associated documentation files (the
;     "Software"), to deal in the Software without restriction, including
;     without limitation the rights to use, copy, modify, merge, publish,
;     distribute, sublicense, and/or sell copies of the Software, and to
;     permit persons to whom the Software is furnished to do so, subject to
;     the following conditions:
;
;     The above copyright notice and this permission notice shall be included
;     in all copies or substantial portions of the Software.
;
;     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
;     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
;     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
;     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
;     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
;     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.;}}}
;=============================================================================

(include "common-macro.vise")

(defvar gosh-repl-directory (substitute (expand "<sfile>:p:h") "\\" "/" "g"))
(defvar gosh-repl-body-path (s+ gosh-repl-directory "/gosh_repl/repl.scm"))

(defun enable-auto-use-exp ();{{{
  (if g:gosh-enable-auto-use
    "(define *enable-auto-use* #t)"
    "(define *enable-auto-use* #f)"));}}}

(defun create-context (proc printer exit-callback);{{{
  (dict 
    (proc proc)
    (printer printer)
    (lines '())
    (prompt_history (dict))
    (exit_callback exit-callback)));}}}

(defmacro open-goshrepl body;{{{
  `(vimproc#popen2
     (s+ "gosh -b"
         " -u gauche.interactive"
         " -I" gosh-repl-directory "/gosh_repl/"
         ,@body)));}}}

(defmacro gosh-repl-body ();{{{
  `(s+ " -e \"(begin " (enable-auto-use-exp) " (include \\\"" gosh-repl-body-path "\\\") (exit))\""));}}}

(defmacro open-goshrepl-with-body ();{{{
  `(open-goshrepl (gosh-repl-body)));}}}

(defun gosh_repl#create_gosh_context (Printer . callback);{{{
  (create-context (open-goshrepl-with-body)
                  Printer
                  (get-rest callback 0)));}}}

(defun gosh_repl#create_gosh_context_with_buf (Printer bufnr . callback);{{{
  (let ((proc (open-goshrepl))
        (exception #f))
    (try 
      (begin
        (dolist [line (getbufline bufnr 1 "$")]
          ((ref proc 'stdin 'write) (s+ line "\n")))
        (sleep '100ms)
        ((ref proc 'stdin 'write) (s+ (gosh-repl-body) "\n")))
      [else
        (set! exception #t)])
    (sleep '100ms)
    (when (or (not (ref proc 'is_valid))
            (not (ref proc 'stdin 'is_valid)) (ref proc 'stdin 'eof)
            (not (ref proc 'stdout 'is_valid)) (ref proc 'stdout 'eof))
      (set! exception #t))
    (create-context
      (if exception
        (begin
          (echo-err (join ((ref proc 'stdout 'read_lines)) "\n"))
          (open-goshrepl-with-body))
        proc)
      Printer 
      (get-rest callback 0))));}}}

(defun gosh_repl#destry_gosh_context (context);{{{
  ((ref context'proc'stdin'close))
  ((ref context'proc'stdout'close))
  (run-exit-callback context));}}}

(defun run-exit-callback (context);{{{
  (when (isnot (ref context 'exit_callback) 0)
    ((ref context 'exit_callback) context)));}}}

(defun gosh_repl#execute_line (context);{{{
  (gosh_repl#execute_text 
    context
    (gosh_repl#get_line_text context (line "."))));}}}

(defun gosh_repl#get_line_text (context num-line);{{{
  (subseq (getline num-line)
          (length (gosh_repl#get_prompt context num-line))));}}}

(defun gosh_repl#execute_text (context text);{{{
  (if (or (not (ref context'proc'is_valid))
        (not (ref context'proc'stdin'is_valid)) 
        (ref context'proc'stdin'eof))
    (run-exit-callback context)
    (begin
      (add (ref context'lines) text)
      ((ref context'proc'stdin'write) 
       (if (!~# text "\n$")
         (s+ text "\n")
         text)))));}}}

(defun gosh_repl#check_output (context . timeout);{{{
  (if (or (not (ref context'proc'is_valid))
        (not (ref context'proc'stdout'is_valid))
        (ref context'proc'stdout'eof))
    (begin
      (run-exit-callback context)
      #f)
    (let1 out (read-output context (get timeout 0 0))
      (if (not (empty out))
        (begin 
          ((ref context 'printer) context out)
          #t)
        #f))));}}}

(defun read-output (context timeout);{{{
  (let1 port (ref context 'proc 'stdout)
    (let loop ((out "")
               (res ((ref port 'read) -1 timeout)))
      (if (empty res)
        out
        (loop (s+ out res)
              ((ref port 'read) -1 15))))));}}}

(defun gosh_repl#get_prompt (context line);{{{
  (if (has_key context "prompt_history")
    (get (ref context 'prompt_history) line "")
    ""));}}}

; vim: foldmethod=marker commentstring=;%s
